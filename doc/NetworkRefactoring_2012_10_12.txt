Network Refactoring 2012-10-12.

What changed?

A simple seriliazation api was introduced. This API serializes messages before they are sent 
over the connection. And deserializes recived message. The folowing types were affected by the change.

Changed:

C#: IServer, Server, IClient, Client, and Program.
Java: IClient, Client, NetworkService, SensorProcessorService NetworkedActivity, KeyboardTestActivity, ComputerActivity


The Following Classes were added.

C#: ISerializer, Serializer<T>, SerializeManager, StringSerializer, ByteArraySerializer, TouchEventSerializer,
   SensorEventSerializer

Java: ISerialzier, Serializer<T>, SerializeManager, StringSerializer, ByteArraySerializer, TouchEventSerializer,
      SensorEventSerializer


Reason:

The end user had to interact with byte arrays as messages. That has worked so far in the project only through
lots of trial and error. Sending was not that hard (if you remembered to add the correct id before each message and pack as byte and not float and so on ^^) 
but reciving was both error prone and annoying. Debugging was a problem since the code used for sending was 
scattered all over the place. The Serialization API solves most of these problems. 

Usage: (End User)

Berfore Refactoring:

Java Code:
Sending Messages Ex: Sending Touch Messages.

Context: We are in some class that has access to a NetworkSerivce and Touch events.

public void sendTouchEvents(TouchEvent event) {
	//Packers help pack data into byte arrays.
	Packer packer = new Packer();

	//Packs the ID so that the reciving end knows that this is a touch event.
	packer.packByte((byte)R.integer.TouchID);
	//Packs the number of touches currently down on the android device.
	packer.packByte((byte)event.Touches.Length);

	for(int i = 0; i < event.Touches.Length;i++) {
		//Packs location and pressure for each touch.
		packer.packShort((short)event.Touches[i].getX());
		packer.packShort((short)event.Touches[i].getY());
		packer.packByte((byte)(event.Touches[i].getPressure() * 256.0f));
	}
	
	//Sends the packed data through the NetworkService.
	this.network.send(packer.getPackedData(), Protocol.Reliable);
}

Reciving Messages ex Reciving Some Arbitrary message.

Context: We are in a class that has access to an instance of IClient.

public void addListeners() {
	this.client.addRecivedListeners(new Action1<byte[]>() {
		public void onAction(byte[] message) {
			UnPacker unpacker = new UnPacker(message);
			while(unpacker.remaining() > 0) {
				//Gets the id of the message.
				int id = unpacker.unpackByte();
				if(id == TOUCH_ID) {
					//Decode the touch event.
					TouchEvent event = decodeTouchEvent(unpacker);
					//Use the event for something.
					this.updateTouchStateMachine(event);
				} else if(id == SOME_OTHER_MESSAGE_ID)
					//Decode some other message.
					SomeOtherMessage message = decodeSomeOtherMessage(unpacker);
					//Use the message somehow.
					this.useMessage(message);
				}
				//...More else if 
			}			
		}
	};
}

Remarks: As can be seen reciving messages are annoying since you must both decode them and use them for something. 
	 The code above contains no sorts of error checking so if encounters unexpected messages if will just crash.



Adding a new type of message: ex CoolMessage

To add a new type of message al that had to be done was to take a new Unique ID pack it befoure the message 
and then pack the contents of the message. 

Context:  We are in some class that has access to a NetworkSerivce and CoolMessages

Ex:

public void sendMyNewCoolMessage(CoolMessage message){
	Packer packer = new Packer();
	//Pack ID
	packer.packByte((byte)R.integer.cool_message);
	//Pack contents of message.
	packer.packInt(message.someIntVar);
	packer.packString(message.someStringVar);

	this.network.send(packer.getPackedMessage(), Protocol.Ordered);
}

Context: We are in the same class as the Recive Arbitrary message example.

public void addListeners() {
	this.client.addRecivedListeners(new Action1<byte[]>() {
		public void onAction(byte[] message) {
			UnPacker unpacker = new UnPacker(message);
			while(unpacker.remaining() > 0) {
				int id = unpacker.unpackByte();
				//...Recive alot of messages.
				} else if(id == COOL_MESSAGE_ID) {
					//Decode the cool message.
					CoolMessage message  = this.decodeCoolMessage(unpacker);
					//Do cool stuff with the message.
					this.doCoolStuff(message);
				}
			}			
		}
	};
}

Remarks: The largest problem with this approach is that new messages cannot even be added to code that you do not control and 
	 if you need to recive data in multiple locations the IDs the decode code and needs to be distributed to all the locations.
	 Another problem is that you need to know that the id is 1 byte long and the first item in a message. This is by far to low 
	 level for any1 getting started with the api.


After Refactoring

Sending Messages Ex: Sending Touch Messages.

public void sendTouchEvents(TouchEvent event) {
	//Sends the event. 
	this.network.send(event, Protocol.Reliable);
}


Reciving Messages ex Reciving Some Arbitrary message.

Context: We are in a class that has access to an instance of IClient.

public void addListeners() {
	this.client.addRecivedListeners(new Action1<byte[]>() {
		public void onAction(Object message) {

				if(message instanceof TouchEvent)  {
					//Use the touch event for something.
					this.updateTouchStateMachine((TouchEvent)message);
				} else if(message instanceof SomeOtherMessage) {
					//Use the message somehow.
					this.useMessage((SomeOtherMessage)message);
				}

			}			
		}
	};
}

Remarks: The Receving code is alot simpler to folow. We stil use if else statements to know the type of the data
	 but we no longer need to decode them ourselfs. 


Adding a new message type: ex CoolMessage


First we create a class that can serialize and deserialize the message.

public class CoolMessageSerializer extends Serializer<CoolMessage>{
	
	public Class<?> getSerializableType() {
		return CoolMessage.class;
	}

	public void serializeInternal(Packer packer, CoolMessage message)
  	{
		//Pack contents of message.
		packer.packInt(message.someIntVar);
		packer.packString(message.someStringVar);
       	}

	public SensorEvent deserialize(UnPacker unpacker)
    	{
        	int id = unpacker.unpackInt();
		String string = unpacker.unpackString();

        	return new CoolMessage(id, string);
	}
}


Context: We are in a class that has access to an instance of IClient or IServer


public void someMethod() {

	//If we are on the client side.
	this.client.registerSerializer(new SomeOtherSerializer());
   	this.client.registerSerializer(new CoolMessageSerializer());

	//If we are on the server side.
	this.server.registerSerializer(new SomeOtherSerializer());
	this.server.registerSerializer(new CoolMessageSerializer());	   
}

Remarks: At the time of this writing the order in wich the serializers are added is EXTREMLY IMPORTANT since the order
they are added decides their ID. This is stil subject to change.



Now the new message is ready to be recived and send over the network. 

To use the new message simply add another else if statement in the reciving message listener. Checking for the CoolMessage type.













